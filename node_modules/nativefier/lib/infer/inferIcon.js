"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inferIcon = void 0;
const path = require("path");
const fs_1 = require("fs");
const util_1 = require("util");
const gitCloud = require("gitcloud");
const pageIcon = require("page-icon");
const helpers_1 = require("../helpers/helpers");
const log = require("loglevel");
const writeFileAsync = util_1.promisify(fs_1.writeFile);
const GITCLOUD_SPACE_DELIMITER = '-';
const GITCLOUD_URL = 'https://jiahaog.github.io/nativefier-icons/';
function getMaxMatchScore(iconWithScores) {
    const score = iconWithScores.reduce((maxScore, currentIcon) => {
        const currentScore = currentIcon.score;
        if (currentScore > maxScore) {
            return currentScore;
        }
        return maxScore;
    }, 0);
    log.debug('Max icon match score:', score);
    return score;
}
function getMatchingIcons(iconsWithScores, maxScore) {
    return iconsWithScores
        .filter((item) => item.score === maxScore)
        .map((item) => (Object.assign(Object.assign({}, item), { ext: path.extname(item.url) })));
}
function mapIconWithMatchScore(cloudIcons, targetUrl) {
    const normalisedTargetUrl = targetUrl.toLowerCase();
    return cloudIcons.map((item) => {
        const itemWords = item.name.split(GITCLOUD_SPACE_DELIMITER);
        const score = itemWords.reduce((currentScore, word) => {
            if (normalisedTargetUrl.includes(word)) {
                return currentScore + 1;
            }
            return currentScore;
        }, 0);
        return Object.assign(Object.assign({}, item), { score });
    });
}
async function inferIconFromStore(targetUrl, platform) {
    log.debug(`Inferring icon from store for ${targetUrl} on ${platform}`);
    const allowedFormats = new Set(helpers_1.getAllowedIconFormats(platform));
    const cloudIcons = await gitCloud(GITCLOUD_URL);
    log.debug(`Got ${cloudIcons.length} icons from gitcloud`);
    const iconWithScores = mapIconWithMatchScore(cloudIcons, targetUrl);
    const maxScore = getMaxMatchScore(iconWithScores);
    if (maxScore === 0) {
        log.debug('No relevant icon in store.');
        return null;
    }
    const iconsMatchingScore = getMatchingIcons(iconWithScores, maxScore);
    const iconsMatchingExt = iconsMatchingScore.filter((icon) => allowedFormats.has(icon.ext));
    const matchingIcon = iconsMatchingExt[0];
    const iconUrl = matchingIcon && matchingIcon.url;
    if (!iconUrl) {
        log.debug('Could not infer icon from store');
        return null;
    }
    return helpers_1.downloadFile(iconUrl);
}
async function inferIcon(targetUrl, platform) {
    log.debug(`Inferring icon for ${targetUrl} on ${platform}`);
    const tmpDirPath = helpers_1.getTempDir('iconinfer');
    let icon = await inferIconFromStore(targetUrl, platform);
    if (!icon) {
        const ext = platform === 'win32' ? '.ico' : '.png';
        log.debug(`Trying to extract a ${ext} icon from the page.`);
        icon = await pageIcon(targetUrl, { ext });
    }
    if (!icon) {
        return null;
    }
    log.debug(`Got an icon from the page.`);
    const iconPath = path.join(tmpDirPath, `/icon${icon.ext}`);
    log.debug(`Writing ${(icon.data.length / 1024).toFixed(1)} kb icon to ${iconPath}`);
    await writeFileAsync(iconPath, icon.data);
    return iconPath;
}
exports.inferIcon = inferIcon;
//# sourceMappingURL=inferIcon.js.map